{"ast":null,"code":"var _jsxFileName = \"/Users/jaseyacey/Desktop/sudokuSolver/sudokusolver/src/Grid.js\";\nimport React from 'react';\nimport range from './cellRange';\n\nclass Grid extends React.Component {\n  constructor() {\n    super();\n    this.gridValues = {};\n    this.solvePuzzle = this.solvePuzzle.bind(this);\n    this.doInitialPass = this.doInitialPass.bind(this);\n    this.makeAnotherPass = this.makeAnotherPass.bind(this);\n    this.isSolved = this.isSolved.bind(this);\n    this.getCellsInRow = this.getCellsInRow.bind(this);\n    this.getCellsInColumn = this.getCellsInColumn.bind(this);\n    this.getCellsInSquare = this.getCellsInSquare.bind(this);\n    this.getPossibleCellValues = this.getPossibleCellValues.bind(this);\n    this.setInputValue = this.setInputValue.bind(this);\n  }\n\n  componentDidMount() {\n    this.rows = [...this.props.rows];\n  }\n\n  solvePuzzle(event) {\n    event.preventDefault();\n    this.doInitialPass();\n\n    while (this.isSolved() === false) {\n      this.makeAnotherPass();\n    }\n\n    return;\n  }\n\n  isSolved() {\n    for (let row = 0; row < this.rows.length; row++) {\n      const len = this.rows[row].filter(cell => !cell.solved).length; // length of array of unsolved cells in this row\n\n      if (len > 0) {\n        // we have unsolved cells, bail now\n        return false;\n      }\n    } // we made it! all cells are solved!\n\n\n    return true;\n  }\n\n  doInitialPass() {\n    // initial pass, update any cells that have values and set them to \"solved\", since our starter cells are given.\n    this.rows.forEach(row => {\n      // row is an array of cells\n      row.forEach(cell => {\n        const inputRef = \"\".concat(cell.row, \".\").concat(cell.column);\n        const input = this.gridValues[inputRef];\n        const val = parseInt(input.value, 10);\n\n        if (!isNaN(val)) {\n          cell.solved = true;\n          cell.value = val;\n        }\n      });\n    });\n  }\n\n  makeAnotherPass() {\n    // naively pass through each cell and check for possible values\n    // if it only has one possible, set it and mark it solved\n    // otherwise, just update possible values and move on\n    this.rows.forEach(row => {\n      // row is an array of cells\n      row.forEach(cell => {\n        if (cell.solved === false) {\n          cell.possibleValues = this.getPossibleCellValues(cell);\n\n          if (cell.possibleValues.length === 1) {\n            cell.solved = true;\n            cell.value = cell.possibleValues[0];\n            this.setInputValue(cell.row, cell.column, cell.value);\n          }\n        }\n      });\n    });\n  }\n\n  getPossibleCellValues(cell) {\n    // get an array of values for each cell in the current row, column, and square\n    const rowVals = this.getCellsInRow(cell.row).filter(it => it.solved).map(it => it.value);\n    const columnVals = this.getCellsInColumn(cell.column).filter(it => it.solved).map(it => it.value);\n    const squareVals = this.getCellsInSquare(cell).filter(it => it.solved).map(it => it.value); // make a unique list of the above values\n\n    const allVals = new Set([...rowVals, ...columnVals, ...squareVals]); // return a filtered list that excludes the solved values from the set above\n\n    return cell.possibleValues.filter(it => allVals.has(it) === false);\n  }\n\n  getCellsInRow(row) {\n    return range.map(column => this.rows[row][column]);\n  }\n\n  getCellsInColumn(column) {\n    return range.map(row => this.rows[row][column]);\n  }\n\n  getCellsInSquare(cell) {\n    // trickier\n    const cells = [];\n    let rowz = [];\n    let cols = [];\n\n    if (cell.row < 3) {\n      rowz = [0, 1, 2];\n    } else if (cell.row < 5) {\n      rowz = [3, 4, 5];\n    } else {\n      rowz = [6, 7, 8];\n    }\n\n    if (cell.column < 3) {\n      cols = [0, 1, 2];\n    } else if (cell.column < 6) {\n      cols = [3, 4, 5];\n    } else {\n      cols = [6, 7, 8, 9];\n    }\n\n    rowz.forEach(row => {\n      cols.forEach(col => {\n        cells.push(this.rows[row][col]);\n      });\n    });\n    return cells;\n  }\n\n  setInputValue(row, column, val) {\n    const inputRef = \"\".concat(row, \".\").concat(column);\n    const input = this.gridValues[inputRef];\n    input.value = val;\n  }\n\n  render() {\n    return React.createElement(\"form\", {\n      className: \"tc\",\n      onSubmit: e => this.solvePuzzle(e),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 144\n      },\n      __self: this\n    }, this.props.rows.map(row => {\n      return React.createElement(\"div\", {\n        key: row[0].row,\n        className: \"grid-row-wrap flex justify-center\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 148\n        },\n        __self: this\n      }, React.createElement(\"span\", {\n        className: \"grid-row flex mw-100\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 149\n        },\n        __self: this\n      }, row.map(cell => {\n        return React.createElement(\"span\", {\n          className: \"grid-cell pa1 dib w2 h2\",\n          key: \"\".concat(row[0].row, \".\").concat(cell.column),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 153\n          },\n          __self: this\n        }, React.createElement(\"input\", {\n          ref: input => this.gridValues[\"\".concat(cell.row, \".\").concat(cell.column)] = input,\n          className: \"pl1 pl2-ns w-100 h2 ba b--transparent\",\n          type: \"number\",\n          min: \"1\",\n          max: \"9\",\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 154\n          },\n          __self: this\n        }));\n      })));\n    }), React.createElement(\"button\", {\n      type: \"submit\",\n      className: \"outline-0 mt4 f6 f5-ns fw6 db w-100 w-auto-ns dib-ns ba b--blue bg-blue white ph3 ph4-ns pv3 br2 grow pointer\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 164\n      },\n      __self: this\n    }, \"Solve!\"));\n  }\n\n}\n\nexport default Grid;","map":{"version":3,"sources":["/Users/jaseyacey/Desktop/sudokuSolver/sudokusolver/src/Grid.js"],"names":["React","range","Grid","Component","constructor","gridValues","solvePuzzle","bind","doInitialPass","makeAnotherPass","isSolved","getCellsInRow","getCellsInColumn","getCellsInSquare","getPossibleCellValues","setInputValue","componentDidMount","rows","props","event","preventDefault","row","length","len","filter","cell","solved","forEach","inputRef","column","input","val","parseInt","value","isNaN","possibleValues","rowVals","it","map","columnVals","squareVals","allVals","Set","has","cells","rowz","cols","col","push","render","e"],"mappings":"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","sourcesContent":["import React from 'react'\nimport range from './cellRange'\n\nclass Grid extends React.Component {\n  constructor() {\n    super()\n    \n    this.gridValues = {}\n    \n    this.solvePuzzle = this.solvePuzzle.bind(this)\n    this.doInitialPass = this.doInitialPass.bind(this)\n    this.makeAnotherPass = this.makeAnotherPass.bind(this)\n    this.isSolved = this.isSolved.bind(this)\n    this.getCellsInRow = this.getCellsInRow.bind(this)\n    this.getCellsInColumn = this.getCellsInColumn.bind(this)\n    this.getCellsInSquare = this.getCellsInSquare.bind(this)\n    this.getPossibleCellValues = this.getPossibleCellValues.bind(this)\n    this.setInputValue = this.setInputValue.bind(this)\n  }\n  \n  componentDidMount() {\n    this.rows = [...this.props.rows]\n  }\n  \n  solvePuzzle(event) {\n    event.preventDefault()\n    this.doInitialPass()\n    \n    while (this.isSolved() === false) {\n      this.makeAnotherPass()\n    }\n    return\n  }\n  \n  isSolved() {\n    for (let row = 0; row < this.rows.length; row++) {\n      const len = this.rows[row].filter(cell => !cell.solved).length // length of array of unsolved cells in this row\n      if (len > 0) {\n        // we have unsolved cells, bail now\n        return false\n      }\n    }\n    \n    // we made it! all cells are solved!\n    return true\n  }\n  \n  doInitialPass() {\n    // initial pass, update any cells that have values and set them to \"solved\", since our starter cells are given.\n    this.rows.forEach(row => {\n      // row is an array of cells\n      row.forEach(cell => {\n        const inputRef = `${cell.row}.${cell.column}`\n        const input = this.gridValues[inputRef]\n        const val = parseInt(input.value, 10)\n        \n        if (!isNaN(val)) {\n          cell.solved = true\n          cell.value = val\n        }\n      })\n    })\n  }\n  \n  makeAnotherPass() {\n    // naively pass through each cell and check for possible values\n    // if it only has one possible, set it and mark it solved\n    // otherwise, just update possible values and move on\n    this.rows.forEach(row => {\n      // row is an array of cells\n      row.forEach(cell => {\n        if (cell.solved === false) {\n          cell.possibleValues = this.getPossibleCellValues(cell)\n          if (cell.possibleValues.length === 1) {\n            cell.solved = true\n            cell.value = cell.possibleValues[0]\n            this.setInputValue(cell.row, cell.column, cell.value)\n          }\n        }\n      })\n    })\n  }\n  \n  getPossibleCellValues(cell) {\n    // get an array of values for each cell in the current row, column, and square\n    const rowVals = this.getCellsInRow(cell.row).filter(it => it.solved).map(it => it.value)\n    const columnVals = this.getCellsInColumn(cell.column).filter(it => it.solved).map(it => it.value)\n    const squareVals = this.getCellsInSquare(cell).filter(it => it.solved).map(it => it.value)\n    \n    // make a unique list of the above values\n    const allVals = new Set([...rowVals, ...columnVals, ...squareVals])\n    \n    // return a filtered list that excludes the solved values from the set above\n    return cell.possibleValues.filter(it => allVals.has(it) === false)\n  }\n  \n  getCellsInRow(row) {\n    return range.map(column => this.rows[row][column])\n  }\n  \n  getCellsInColumn(column) {\n    return range.map(row => this.rows[row][column])\n  }\n  \n  getCellsInSquare(cell) {\n    // trickier\n    const cells = []\n    let rowz = []\n    let cols = []\n    \n    if (cell.row < 3) {\n      rowz = [0,1,2]\n    } else if (cell.row < 5) {\n      rowz = [3,4,5]\n    } else {\n      rowz = [6,7,8]\n    }\n    \n    if (cell.column < 3) {\n      cols = [0,1,2]\n    } else if (cell.column < 6) {\n      cols = [3,4,5]\n    } else {\n      cols = [6,7,8,9]\n    }\n    \n    rowz.forEach(row => {\n      cols.forEach(col => {\n        cells.push(this.rows[row][col])\n      })\n    })\n    \n    return cells\n  }\n  \n  setInputValue(row, column, val) {\n    const inputRef = `${row}.${column}`\n    const input = this.gridValues[inputRef]\n    input.value = val\n  }\n  \n  render() {\n    return (\n      <form className=\"tc\" onSubmit={(e) => this.solvePuzzle(e)}>\n        {\n          this.props.rows.map(row => {\n            return (\n              <div key={row[0].row} className=\"grid-row-wrap flex justify-center\">\n                <span className=\"grid-row flex mw-100\">\n                {\n                  row.map(cell => {\n                    return (\n                      <span className=\"grid-cell pa1 dib w2 h2\" key={`${row[0].row}.${cell.column}`}>\n                        <input ref={(input) => this.gridValues[`${cell.row}.${cell.column}`] = input} className=\"pl1 pl2-ns w-100 h2 ba b--transparent\" type=\"number\" min=\"1\" max=\"9\" />\n                      </span>\n                    )\n                  })\n                }\n                </span>\n              </div>\n            )\n          })\n        }\n        <button type=\"submit\" className=\"outline-0 mt4 f6 f5-ns fw6 db w-100 w-auto-ns dib-ns ba b--blue bg-blue white ph3 ph4-ns pv3 br2 grow pointer\">Solve!</button>\n      </form>\n    )\n  }\n}\n\nexport default Grid; \n"]},"metadata":{},"sourceType":"module"}